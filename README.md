# django-plotly-dash

OBS: This file is a copy from [django-plotly-dash README.md](https://github.com/GibbsConsulting/django-plotly-dash/blob/master/README.md), so I will be able to reproduce the steps that I took to make it work.

Expose [plotly dash](https://plot.ly/products/dash/) apps as [Django](https://www.djangoproject.com/) tags. Multiple Dash apps can
then be embedded into a single web page, persist and share internal state, and also have access to the
current user and session variables.

See the source for this project here:
<https://github.com/GibbsConsulting/django-plotly-dash>

This README file provides a short guide to installing and using the package, and also
outlines how to run the demonstration application.

More detailed information
can be found in the online documentation at
<https://readthedocs.org/projects/django-plotly-dash>

An online version of the demo can be found at <https://djangoplotlydash.com>


## Installation

First, install the package. This will also install plotly and some dash packages if they are not already present.

    pip install django_plotly_dash

Then, add `django_plotly_dash` to `INSTALLED_APPS` in your Django `settings.py` file

    INSTALLED_APPS = [
        ...
        'django_plotly_dash.apps.DjangoPlotlyDashConfig',
        ...
        ]

The application's routes need to be registered within the routing structure by an appropriate ``include`` statement in
a ``urls.py`` file:

    urlpatterns = [
        ...
        path('django_plotly_dash/', include('django_plotly_dash.urls')),
    ]

The name within the URL is not important and can be changed.

For the final installation step, a migration is needed to update the
database:

    ./manage.py migrate

If using version 3.0 or later of Django, then the use of frames within
HTML documents has to be enabled by adding to the ``settings.py`` file:

    X_FRAME_OPTIONS = 'SAMEORIGIN'


Further configuration, including live updating to share application
state, is described in the [online documentation](https://django-plotly-dash.readthedocs.io/en/latest/).


## plotly_direct tag

The plotly_direct template tag
This template tag allows the direct insertion of html into a template, instead of embedding it in an iframe.

```jinja2
{%load plotly_dash%}

{%plotly_direct name="SimpleExample"%}
```

The tag arguments are:

name = None:	The name of the application, as passed to a DjangoDash constructor.
slug = None:	The slug of an existing DashApp instance.
da = None:	An existing django_plotly_dash.models.DashApp model instance.
These arguments are equivalent to the same ones for the plotly_app template tag. Note that initial_arguments are not currently supported, and as the app is directly injected into the page there are no arguments to control the size of the iframe.

This tag should not appear more than once on a page. This rule however is not enforced at present.

If this tag is used, then the header and footer tags should also be added to the template. Note that these tags in turn have middleware requirements.

The plotly_header and plotly_footer template tags
DjangoDash allows you to inject directly the html generated by Dash in the DOM of the page without wrapping it in an iframe. To include the app CSS and JS, two tags should be included in the template, namely plotly_header and plotly_footer, as follows:

```html
<!-- templates/base.html -->
<!DOCTYPE html>
<html>
    <head>
    ...
    {% load plotly_dash%} <!-- MANDATORY TAG IN ORDER TO MAKE IT WORK -->
    ...
    {% plotly_header %} <!-- MANDATORY TAG IN ORDER TO MAKE IT WORK -->
    ...
    </head>
    <body>
    ...
    {%plotly_direct name="SimpleExample"%} <!-- MANDATORY TAG IN ORDER TO MAKE IT WORK -->
    ...
    </body>
    ...
    {% plotly_footer %} <!-- MANDATORY TAG IN ORDER TO MAKE IT WORK -->
</html>
```

This part in mandatory if you want to use the plotly_direct tag, and these two tags can safely be included on any page that has loaded the plotly_dash template tag library with minimal overhead, making them suitable for inclusion in a base template. Neither tag has any arguments.

Note that if you are using any functionality that needs the use of these tags, then the associated middleware should be added in settings.py
```python
MIDDLEWARE = [
               ...

               'django_plotly_dash.middleware.BaseMiddleware',

             ]
```
This middleware should appear low down the middleware list.

Install packages to make it work:

```console
foo@bar:~$ pip install dash==1.20.0 dash-bootstrap-components==0.13.1 dash-core-components==1.16.0 dash-html-components==1.1.3 dash-renderer==1.9.1 dash-table==4.11.3 Django==3.2.8 django-plotly-dash==1.6.6 dpd-components==0.1.0 dpd-static-support==0.0.5 pandas==1.3.4 whitenoise==5.3.0
```

AND MAYBE:

```console
foo@bar:~$ pip install pathlib ruamel-yaml sphinx django-plotly-dash
```



## Usage Example

To use existing dash applications, first register them using the `DjangoDash` class. This
replaces the `Dash` class of the `dash` package.

Taking a very simple example inspired by the excellent [getting started](https://dash.plot.ly/) documentation:

```python
import dash
import dash_core_components as dcc
import dash_html_components as html

from django_plotly_dash import DjangoDash

app = DjangoDash('SimpleExample')

app.layout = html.Div([
    dcc.RadioItems(
        id='dropdown-color',
        options=[{'label': c, 'value': c.lower()} for c in ['Red', 'Green', 'Blue']],
        value='red'
    ),
    html.Div(id='output-color'),
    dcc.RadioItems(
        id='dropdown-size',
        options=[{'label': i, 'value': j} for i, j in [('L','large'), ('M','medium'), ('S','small')]],
        value='medium'
    ),
    html.Div(id='output-size')

])

@app.callback(
    dash.dependencies.Output('output-color', 'children'),
    [dash.dependencies.Input('dropdown-color', 'value')])
def callback_color(dropdown_value):
    return "The selected color is %s." % dropdown_value

@app.callback(
    dash.dependencies.Output('output-size', 'children'),
    [dash.dependencies.Input('dropdown-color', 'value'),
     dash.dependencies.Input('dropdown-size', 'value')])
def callback_size(dropdown_color, dropdown_size):
    return "The chosen T-shirt is a %s %s one." %(dropdown_size,
                                                  dropdown_color)
```

Note that the `DjangoDash` constructor requires a name to be specified. This name is then used to identify the dash app in
templates:

```jinja2
{% load plotly_dash %}

{% plotly_app name="SimpleExample" %}
```

The registration code needs to be in a location
that will be imported into the Django process before any model or template tag attempts to use it. The example Django application
in the demo subdirectory achieves this through an import in the main `urls.py` file; any `views.py` would also be sufficient.

Whilst this example allows for the direct use of existing `Dash` applications, it does not provide for the sharing or updating of
internal state. The [online documentation](https://django-plotly-dash.readthedocs.io/en/latest/) provides details on using these
and other additional features.


## My app
settings.py


```python

...

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    #bootstrap4
    "bootstrap4",

    #django-plotly-dash
    'django_plotly_dash.apps.DjangoPlotlyDashConfig',
    'dpd_static_support',
    
    #apps
    'eixo_7_energia.apps.Eixo7EnergiaConfig'
]

# DJANGO-PLOTLY-DASH
# If using version 3.0 or later of Django, then the use of frames within HTML documents has to be enabled
X_FRAME_OPTIONS = 'SAMEORIGIN'
CRISPY_TEMPLATE_PACK = 'bootstrap4'

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    
    # PLOTLY
    'whitenoise.middleware.WhiteNoiseMiddleware',

    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',

    # PLOTLY
    'django_plotly_dash.middleware.ExternalRedirectionMiddleware',
    'django_plotly_dash.middleware.BaseMiddleware',
]

...

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]


...

PLOTLY_DASH = {

    # Route used for the message pipe websocket connection
    "ws_route" :   "dpd/ws/channel",

    # Route used for direct http insertion of pipe messages
    "http_route" : "dpd/views",

    # Flag controlling existince of http poke endpoint
    "http_poke_enabled" : True,

    # Insert data for the demo when migrating
    "insert_demo_migrations" : False,

    # Timeout for caching of initial arguments in seconds
    "cache_timeout_initial_arguments": 60,

    # Name of view wrapping function
    "view_decorator": None,

    # Flag to control location of initial argument storage
    "cache_arguments": True,

    # Flag controlling local serving of assets
    "serve_locally": False,
}

# Staticfiles finders for locating dash app assets and related files

STATICFILES_FINDERS = [

    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',

    'django_plotly_dash.finders.DashAssetFinder',
    'django_plotly_dash.finders.DashComponentFinder',
    'django_plotly_dash.finders.DashAppDirectoryFinder',
]


# Plotly components containing static content that should
# be handled by the Django staticfiles infrastructure

PLOTLY_COMPONENTS = [

    # Common components
    'dash_core_components',
    'dash_html_components',
    'dash_renderer',

    # django-plotly-dash components
    'dpd_components',
    # static support if serving local assets
    'dpd_static_support',

    # Other components, as needed
    'dash_bootstrap_components',
]


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/3.2/howto/static-files/

STATIC_URL = '/static/'
```

Dash Plotly Structure:
```console
.
├── ...
├── eixo_7_energia          # django app created using python manage.py startapp
│   ├── dashboard           # dash-plotly app root folder
│   |    ├── app.py         # file with dash plotly app declaration (app = DjangoDash)
│   |    ├── dashboard.py   # main dash plotly file which imports app.py and apps
│   |    ├── apps           # folder containing all dashboards
│   |    |   ├── app1.py    # dashboard 1 which can be a tab in the main panel
│   |    |   ├── app2.py    # dashboard 2 which can be a tab in the main panel
│   |    |   ├── app3.py    # dashboard 3 which can be a tab in the main panel
│   |    |   └── ...
│   |    ├── assets         # css and javascript assets if needed (OBS: NOT NECESSARY IN DJANGO APPLICATION)
│   |    └── ...
│   ├── urls.py             # urls file to register our apps and our pages
│   ├── views.py            # our views file to render html files
│   ├── models.py           # django models
│   ├── static              # static files (css, js, img)
│   |    ├── css            # css files
│   |    |   ├── style.css  # style css file
│   |    |   └── ...
│   |    ├── js             # js files
│   |    |   ├── script.js    # main js file
│   |    |   └── ...
│   |    ├── img            # images folder
│   |    |   ├── p.png      # image file
│   |    |   └── ...
│   |    └── ...
│   ├── templates           # templates folder with all html files
│   |    ├── base.html      # html file
│   |    ├── home.html      # html file
│   |    └── ...
│   └── ...                 # etc.
└── ...
```

eixo_7_energia/urls.py
```python

from django.urls import path
from . import views
from .dashboard import dashboard #registering our dashboard app

urlpatterns = [
    path('', views.dashboard, name='eixo_7_energia'),
]

```

eixo_7_energia/views.py
```python

from django.shortcuts import render

# Create your views here.
def dashboard(requests):
    return render(requests,'eixo_7_energia/dashboard.html')

```

urls.py (main urls.py file)
```python

from django.contrib import admin
from django.urls import path, include


urlpatterns = [
    path('admin/', admin.site.urls),
    path('django_plotly_dash/', include('django_plotly_dash.urls')),
    path('', include('eixo_7_energia.urls')),
]


```

# Deploy Heroku

Creating the virtual environment
```console
foo@bar:~$ python3 -m venv ./venv --prompt django_heroku
```

Activate the virtual environment
```console
foo@bar:~$ source venv/bin/activate
```

Creating gitignore file
```console
foo@bar:~$ curl https://www.toptal.com/developers/gitignore/api/python,django > .gitignore
```

Creating application on heroku
```console
foo@bar:~$ heroku create project-name
```

Linking the heroku repository to application
```console
foo@bar:~$ heroku git:remote --app project-name
```

You can define it in a file named Procfile, which must be placed in my project root directory.

The Procfile is a single, language-agnostic format for defining the processes making up your project. It will instruct Heroku on how to run your web server. Although working with the built-in development server isn’t the recommended practice for running a Django project in production, you can use it for this exercise:

```console
foo@bar:~$ echo "web: python manage.py runserver 0.0.0.0:\$PORT" > Procfile
foo@bar:~$ git add Procfile
foo@bar:~$ git commit -m "Specify the command to run your project"
```
To make the server accessible from the world outside of the Heroku cloud, you specify the address as 0.0.0.0 instead of the default localhost. It will bind the server on a public network interface. Heroku provides the port number through the PORT environment variable.

You can now test this configuration by running your Django project locally using the Heroku CLI:
```console
foo@bar:~$ heroku local
```
By default, if you don’t specify a process type explicitly, it’ll run the web process. The heroku local command is the same as heroku local web. Also, if you don’t set the port number with the --port flag, then it’ll use the default port 5000.

You’ve now specified the processes you want Heroku to run. When you open the URL http://localhost:5000/ in your web browser, then you should see the familiar rocket on the Django welcome page again. However, to access the same resource through the public interface at http://0.0.0.0:5000/, you’ll need to tweak the Django configuration, or else you’ll receive a Bad Request error.

Setting django application to heroku
```console
foo@bar:~$ pip install django-heroku
foo@bar:~$ pip freeze > requirements.txt
```

settings.py
```console
foo@bar:~$ echo "import django_heroku" >> settings.py
foo@bar:~$ echo "django_heroku.settings(locals())" >> settings.py
```

Generating SECRET_KEY django
```console
foo@bar:~$ echo "SECRET_KEY='$(openssl rand -base64 32)'" > .env
```

In portfolio/settings.py, find the auto-generated line where Django defines the SECRET_KEY variable and comment it out:
```python
# SECURITY WARNING: keep the secret key used in production secret!
# SECRET_KEY = 'django-insecure-#+^6_jx%8rmq9oa(frs7ro4pvr6qn7...
```

Setting the heroku env variable
```console
foo@bar:~$ heroku config:set SECRET_KEY='6aj9il2xu2vqwvnitsg@!+4-8t3%zwr@$agm7x%o%yb2t9ivt%'
```

Commiting the changes
```console
foo@bar:~$ git add .
foo@bar:~$ git commit -m "Remove a hardcoded Django secret key"
foo@bar:~$ git push heroku master
```

Finishing the configurations to run the dash application
```console
foo@bar:~$ heroku run python manage.py makemigrations
foo@bar:~$ heroku run python manage.py migrate
```

Tutorial: https://realpython.com/django-hosting-on-heroku/